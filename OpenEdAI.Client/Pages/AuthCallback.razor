@using System.Text.Json.Serialization
@using System.Text.Json
@using OpenEdAI.Client.Models
@using OpenEdAI.Client.Shared
@page "/auth-callback"
@inject Services.LoadingService Loader
@inject NavigationManager Navigation
@inject HttpClient Http
@inject IJSRuntime JS
@inject Services.TokenManager TokenManager
@inject Services.StudentService StudentService

<GlobalLoading /> 

@code {
	private bool _hasExchangedCode = false;

	protected override async Task OnInitializedAsync()
	{
		// Check for an existing, valid token
		var existingToken = await JS.InvokeAsync<string>("localStorage.getItem", "access_token");
		if (!string.IsNullOrWhiteSpace(existingToken) && existingToken != "null" && TokenManager.IsTokenValid(existingToken))
		{
			Console.WriteLine("[AuthCallback] Existing access token found. Redirecting to dashboard.");
			_hasExchangedCode = true;
			await DeterminePostAuthNavigation();
			return;
		}

		// Prevent multiple code exchanges
		if (_hasExchangedCode)
		{
			Console.WriteLine("[AuthCallback] _hasExchangedCode is true. Redirecting to dashboard.");
			Navigation.NavigateTo("/dashboard", replace: true);
			return;
		}

		Loader.Show();

		var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
		var query = System.Web.HttpUtility.ParseQueryString(uri.Query);

		var code = query.Get("code");

		// If there is no code, clear the URL to avoid duplicate exchanges and redirect to the landing page
		if (string.IsNullOrEmpty(code))
		{
			Console.WriteLine("No code found in query string. Redirecting to landing page");
			Navigation.NavigateTo("/", forceLoad: true);
			return;
		}

		try
		{
			Console.WriteLine($"Sending code to backend for exchange: {code}");

			var payload = new AuthCodeExchangeRequest { Code = code };
			var payloadJson = JsonSerializer.Serialize(payload);
			Console.WriteLine($"Payload being sent to /auth/exchange: {payloadJson}"); 

			var response = await Http.PostAsJsonAsync("auth/exchange", payload);

			if (response.IsSuccessStatusCode)
			{
				// Read the raw JSON response for debugging
				var tokenJson = await response.Content.ReadAsStringAsync();
				Console.WriteLine("Received token response: " + tokenJson);

				// Deserialize using case-insensitive property names
				var token = JsonSerializer.Deserialize<AuthTokenResponse>(
					tokenJson,
					new JsonSerializerOptions { PropertyNameCaseInsensitive = true }
				);

				if (token != null)
				{
					Console.WriteLine("Parsed AccessToken: " + token.AccessToken);
					Console.WriteLine("Parsed RefreshToken: " + token.RefreshToken);

					// Clear any old tokens before storing the new ones
					Console.WriteLine("Clearing old tokens...");
					await ClearTokensAsync();

					// Store the access token using the TokenManager
					await TokenManager.SetTokenAsync(token.AccessToken);

					// Store the refresh token separately
					if (!string.IsNullOrWhiteSpace(token.RefreshToken))
					{
						await JS.InvokeVoidAsync("localStorage.setItem", "refresh_token", token.RefreshToken);
					}

					Console.WriteLine("Tokens stored successfully.");

					// Debug: Read them back and log
					var storedAccessToken = await JS.InvokeAsync<string>("localStorage.getItem", "access_token");
					var storedRefreshToken = await JS.InvokeAsync<string>("localStorage.getItem", "refresh_token");

					_hasExchangedCode = true;
					Console.WriteLine("[AuthCallback] _hasExchangedCode = true");

					Console.WriteLine($"[AuthCallback] Stored access_token: {storedAccessToken}");
					Console.WriteLine($"[AuthCallback] Stored refresh_token: {storedRefreshToken}");

					// Wait for a second before redirecting to give the JS time to store the tokens
					Console.WriteLine("Waiting for 200ms before redirecting...");
					await Task.Delay(200);
					// Redirect accordingly
					await DeterminePostAuthNavigation();
				}
				else
				{
					Console.WriteLine("Received null token object.");
					Navigation.NavigateTo("/", forceLoad: false);
				}

			}
			else
			{
				Console.WriteLine($"[AuthCallback] Token exchange failed. Status: {response.StatusCode}");
				var errorContent = await response.Content.ReadAsStringAsync();
				Console.WriteLine($"[AuthCallback] Error content: {errorContent}");
				Console.WriteLine($"[AuthCallback] Redirecting to landing page.");
				Navigation.NavigateTo("/", forceLoad: false);
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Exception during token exchange: {ex.Message}");
			Navigation.NavigateTo("/", forceLoad: false);
		}
		finally
		{
			Loader.Hide();
		}
	}

	// Determine whether the student has completed the initial setup and navigate accordingly
	private async Task DeterminePostAuthNavigation()
	{
		try
		{
			// Retrieve the student data using the StudentService
			var student = await StudentService.GetCurrentStudentAsync();

			if (student == null)
			{
				Console.WriteLine("Student not found. Redirecting to landing page.");
				Navigation.NavigateTo("/", replace: true);
				return;
			}

			if (!student.HasCompletedSetup && student.Profile == null)
			{
				Console.WriteLine("Student has not completed setup. Redirecting to profile page.");
				Navigation.NavigateTo("/profile", replace: true);
			}
			else if (!student.HasCompletedSetup)
			{
				Console.WriteLine("Student has completed profile, but not completed setup. Redirecting to generate-course page.");
				Navigation.NavigateTo("/generate-course", replace: true);
			}
			else
			{
				Console.WriteLine("Student setup complete. Redirecting to dashboard.");
				Navigation.NavigateTo("/dashboard", replace: true);
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"Error during post-authentication navigation: {ex.Message}");
			Navigation.NavigateTo("/", forceLoad: false);
		}
		finally
		{
			Loader.Hide();
		}
	}

	// Helper method to clear old tokens from localStorage
	private async Task ClearTokensAsync()
	{
		Console.WriteLine("Clearing old tokens from localStorage...");
		await JS.InvokeVoidAsync("localStorage.removeItem", "access_token");
		await JS.InvokeVoidAsync("localStorage.removeItem", "refresh_token");
	}

	public class AuthCodeExchangeRequest
	{
		public string Code { get; set; }
	}
}